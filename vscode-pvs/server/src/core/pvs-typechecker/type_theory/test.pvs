%--------------------
% Example sequence for testing the operational semantics of the typechecker
% The sequence would be generated when typechecking the following theory
% test: THEORY BEGIN
%   foo: TYPE
%   foo: nat   %-- note: terms can have the same name of types declared in the context
%   foo2(x: nat, y: nat): nat = LET z: nat = x + y IN z
% END test
%--------------------
test: THEORY
  BEGIN IMPORTING typechecker

    cc1: typecheck_context = enter_type_declaration(pretype("foo"), initial_context)
    cc2: typecheck_context = enter_constant_declaration(constant_preterm("foo", "nat"), cc1)
    cc3: typecheck_context = enter_function_declaration(function_preterm("foo2", (: "nat", "nat" :)), cc2)
    cc4: typecheck_context = enter_function_arguments((: preterm("x", "nat"), preterm("y", "nat") :), cc3)

    %--------------------
    % test cases
    %--------------------

    init_test_1: boolean = member?(pretype("bool"), initial_context) % this should be true
    fresh_test_1: boolean = fresh?(pretype("bool"), initial_context) % this should be false

    equiv_test_1: boolean = pretype("bool") = pretype("bool") % this should be true
    equiv_test_2: boolean = pretype("bool") = pretype("int") % this should be false

    % foo type can be defined in the initial context
    cc1_typechecks: boolean = typechecks?(cc1) AND member?(pretype("foo"), cc1)
    % redefinition is rejected
    cc1_red: boolean = LET cc1 = enter_type_declaration(pretype("foo"), cc1) IN NOT typechecks?(cc1)

    % foo constant can be defined in cc1
    cc2_typechecks: boolean = typechecks?(cc2) AND member?(preterm("foo", "nat"), cc2)
    % redefinition is rejected
    cc2_red: boolean = LET cc2 = enter_constant_declaration(preterm("foo", "nat"), cc2) IN NOT typechecks?(cc2)

  END test