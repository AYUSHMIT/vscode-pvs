basics: THEORY
  BEGIN 
    % each symbol has a kind, one of type_kind, term_kind
    kind: TYPE = { type_kind, term_kind }

    % symbols can be built-in, uninterpreted, or interpreted
    symbol: DATATYPE
      BEGIN 
        builtin(kind: kind, signature: list[int]): builtin?
        uninterpreted(kind: kind, signature: list[int]): uninterpreted?
        interpreted(kind: kind, signature: list[int], def: int): interpreted?
      END symbol

    % name equivalence (synonym: weak equivalence)
    equiv_name(s1, s2: symbol)
      : boolean = 
        kind(s1) = kind(s2)
        % AND signature(s1) = signature(s2)
        AND signature(s1)`length = signature(s2)`length 
        AND LET n: int = signature(s1)`length 
             IN FORALL (i: below(n)): nth(signature(s1), i) = nth(signature(s2), i)
    ;≡(s1, s2: symbol): boolean = equiv_name(s1, s2)

    % definition equivalence (synonims: equality, strong equivalence)
    equiv_def(s1, s2: symbol)
      : boolean = 
        ≡(s1, s2) % why is infix notation not supported???
        AND (interpreted?(s1) IMPLIES interpreted?(s2) AND def(s1) = def(s2))
        AND (interpreted?(s2) IMPLIES interpreted?(s1) AND def(s1) = def(s2))
    ;=(s1, s2: symbol): boolean = equiv_def(s1, s2)
    
    % pretype constructors
    basic_type(name: int): symbol = builtin(type_kind, (: name :))
    pretype(name: int): symbol = uninterpreted(type_kind, (: name :))
    pretype(name: int, def: int): symbol = interpreted(type_kind, (: name :), def)
    pretype(name: int, args: list[int]): symbol = uninterpreted(type_kind, (: name :) o args)
    pretype(name: int, args: list[int], ret: int): symbol = uninterpreted(type_kind, (: name :) o args)
    pretype(name: int, args: list[int], ret: int, def: int): symbol = interpreted(type_kind, (: name :) o args, def)

    % preterm constructors
    preterm(name: int): symbol = uninterpreted(term_kind, (: name :))
    preterm(name: int, def: int): symbol = interpreted(term_kind, (: name :), def)
    preterm(name: int, args: list[int]): symbol = uninterpreted(term_kind, (: name :) o args)

  END basics
