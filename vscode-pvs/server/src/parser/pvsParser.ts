const antlr4 = require('antlr4/index');
const PvsLanguageLexer = require('./dist/PvsLanguageLexer').PvsLanguageLexer;
const PvsLanguageParser = require('./dist/PvsLanguageParser').PvsLanguageParser;
const PvsLanguageListener = require('./dist/PvsLanguageListener').PvsLanguageListener;
import * as fsUtils from '../common/fsUtils';
import { DiagnosticSeverity, Diagnostic, Position, Range } from 'vscode-languageserver';

export declare class Symbol {
    channel: number;
    column: number;
    line: number;
    start: number;
    stop: number;
    text: string;
    tokenIndex: number;
    type: number;
};
// @Override
// PvsLanguageListener.prototype.enterParse = function(ctx) {
// 	console.log(ctx.getText());
// };
class PvsLanguageErrorListener extends antlr4.error.ErrorListener {
    protected errors: Diagnostic[] = [];
	constructor(errors: Diagnostic[]) {
		super();
		this.errors = errors;
    }
    /**
     * 
     * @param recognizer What parser got the error. From this object, you can access the context as well as the input stream.
     * @param offendingSymbol The offending token in the input token stream, unless recognizer is a lexer (then it's null). If no viable alternative error, syntaxError has token at which we started production for the decision.
     * @param line The line number in the input where the error occurred.
     * @param col The character position within that line where the error occurred.
     * @param message The message to emit.
     * @param syntaxError The exception generated by the parser that led to the reporting of an error. It is null in the case where the parser was able to recover in line without exiting the surrounding rule.
     */
	syntaxError(recognizer, offendingSymbol: Symbol, line: number, col: number, message: string, syntaxError) {
        const start: Position = { line: line, character: col };
        const len: number = offendingSymbol.stop - offendingSymbol.start;
        const end: Position = { line: line, character: col + 1 + len };
        const range: Range = { start, end };
        const diag: Diagnostic = { range, message, severity: DiagnosticSeverity.Error };
		this.errors.push(diag);
	}
}

export class PvsParser extends PvsLanguageListener {
    enterFunctionDeclaration (ctx) {
        // const tokens = parser.getTokenStream();
        
        const body: string = ctx.expr().toString();
        console.dir(body);

        // // console.log(ctx.getText());
        // // const identifiers = ctx.identifiers();
        // // console.log(identifiers);
        // const tp = tokens.getText(ctx.identifiers());
        // console.log(tp);
        // // const expr = ctx.expr().getText();
        // // console.log(expr);
    }

    async parseFile (desc: { fileName: string, fileExtension: string, contextFolder: string }): Promise<Diagnostic[]> {
        const fname: string = fsUtils.desc2fname(desc);
        console.info(`[vscode-pvs-parser] Parsing ${fname}`);
        const input: string = await fsUtils.readFile(fname);
        
        const chars = new antlr4.InputStream(input.toLocaleString());
        const lexer = new PvsLanguageLexer(chars);
        const tokens = new antlr4.CommonTokenStream(lexer);
        const parser = new PvsLanguageParser(tokens);

        parser.buildParseTrees = false; // presumably this will speed up parsing?
        parser.removeErrorListeners();

        const errors: Diagnostic[] = [];
        parser.addErrorListener(new PvsLanguageErrorListener(errors));

        return new Promise ((resolve, reject) => {
            const tree = parser.parse(); // this invocation may take time
            if (errors.length) {
                console.log(`[vscode-pvs-parser] File ${desc.fileName}${desc.fileExtension} contains errors`);
                console.dir(errors, { depth: null });
            } else {
                console.log(`[vscode-pvs-parser] File ${desc.fileName}${desc.fileExtension} parsed successfully!`);
                // console.log(tree);
            }
            resolve(errors);    
        })

        // const listener = new PvsLanguageListener();
        // antlr4.tree.ParseTreeWalker.DEFAULT.walk(listener, tree);
        // console.log("\n\n" + tree.toStringTree());

    }
}

// PvsLanguageListener.prototype.enterExpr = function(ctx) {
// 	console.log(ctx.getText());
// };

// PvsLanguageListener.prototype.enterQuantifier_expression = function(ctx) {
// 	console.log(ctx.getText());
// };

