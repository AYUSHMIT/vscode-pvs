const antlr4 = require('antlr4/index');
const PvsLanguageLexer = require('./PvsLanguageLexer').PvsLanguageLexer;
const PvsLanguageParser = require('./PvsLanguageParser').PvsLanguageParser;
const PvsLanguageListener = require('./PvsLanguageListener').PvsLanguageListener;
import * as fsUtils from '../../common/fsUtils';
import { DiagnosticSeverity, Diagnostic, Position, Range } from 'vscode-languageserver';
import { DefaultErrorStrategy, BailErrorStrategy } from 'antlr4/error/ErrorStrategy';
import { PredictionMode } from 'antlr4/atn/PredictionMode';

export declare class Symbol {
    channel: number;
    column: number;
    line: number;
    start: number;
    stop: number;
    text: string;
    tokenIndex: number;
    type: number;
};
export declare class Parser {
    // from the pvs grammar
    parse ();
    // from antlr Parser.js
    buildParseTrees: boolean;
    _errHandler: DefaultErrorStrategy | BailErrorStrategy;
    // from antlr Recognizer.js
    addErrorListener(listener): void;
    removeErrorListeners(): void;
    _interp: {
        predictionMode: PredictionMode
    };

}
// @Override
// PvsLanguageListener.prototype.enterParse = function(ctx) {
// 	console.log(ctx.getText());
// };
class PvsLanguageErrorListener extends antlr4.error.ErrorListener {
    protected errors: Diagnostic[] = [];
	constructor(errors: Diagnostic[]) {
		super();
		this.errors = errors;
    }
    /**
     * 
     * @param recognizer What parser got the error. From this object, you can access the context as well as the input stream.
     * @param offendingSymbol The offending token in the input token stream, unless recognizer is a lexer (then it's null). If no viable alternative error, syntaxError has token at which we started production for the decision.
     * @param line The line number in the input where the error occurred.
     * @param col The character position within that line where the error occurred.
     * @param message The message to emit.
     * @param syntaxError The exception generated by the parser that led to the reporting of an error. It is null in the case where the parser was able to recover in line without exiting the surrounding rule.
     */
	syntaxError(recognizer, offendingSymbol: Symbol, line: number, col: number, message: string, syntaxError) {
        const start: Position = { line: line, character: col };
        const len: number = offendingSymbol.stop - offendingSymbol.start;
        const end: Position = { line: line, character: col + 1 + len };
        const range: Range = { start, end };
        const diag: Diagnostic = { range, message, severity: DiagnosticSeverity.Error };
		this.errors.push(diag);
	}
}

export class PvsParser {
    /**
     * Parse a pvs file
     * @param desc File descriptor, includes file name, file extension, and context folder
     */
    async parseFile (desc: { fileName: string, fileExtension: string, contextFolder: string }): Promise<Diagnostic[]> {
        const fname: string = fsUtils.desc2fname(desc);
        console.info(`[vscode-pvs-parser] Parsing ${fname}`);
        const input: string = await fsUtils.readFile(fname);
        
        const chars = new antlr4.InputStream(input.toLocaleString());
        const lexer = new PvsLanguageLexer(chars);
        const tokens = new antlr4.CommonTokenStream(lexer);
        const parser: Parser = new PvsLanguageParser(tokens);

        parser.buildParseTrees = false; // setting buildParseTrees to false should improve performance?
        // parser._errHandler = new BailErrorStrategy(); // using BailErrorStrategy should improve performance?

        const errors: Diagnostic[] = [];
        parser.removeErrorListeners();
        parser.addErrorListener(new PvsLanguageErrorListener(errors));

        return new Promise ((resolve, reject) => {

            parser._interp.predictionMode = PredictionMode.LL; //SLL is the fastest but fails to resolve ambiguities, LL is default, LL_EXACT_AMBIG_DETECTION is the slowest
            const tree = parser.parse(); // this invocation may take time
            
            // logic for processing the parse tree
            // const listener = new PvsLanguageListener();
            // antlr4.tree.ParseTreeWalker.DEFAULT.walk(listener, tree);
            
            if (errors.length) {
                console.log(`[vscode-pvs-parser] File ${desc.fileName}${desc.fileExtension} contains errors`);
                console.dir(errors, { depth: null });
            } else {
                console.log(`[vscode-pvs-parser] File ${desc.fileName}${desc.fileExtension} parsed successfully!`);
                // console.log(tree);
            }
            resolve(errors);    
        });
    }

    // @Override
    /*
    enterFunctionDeclaration (ctx) {
        // const tokens = parser.getTokenStream();
        
        // const body: string = ctx.expr().toString();
        // console.dir(body);

        // // console.log(ctx.getText());
        // // const identifiers = ctx.identifiers();
        // // console.log(identifiers);
        // const tp = tokens.getText(ctx.identifiers());
        // console.log(tp);
        // // const expr = ctx.expr().getText();
        // // console.log(expr);
    }
    */

}

// PvsLanguageListener.prototype.enterExpr = function(ctx) {
// 	console.log(ctx.getText());
// };

// PvsLanguageListener.prototype.enterQuantifier_expression = function(ctx) {
// 	console.log(ctx.getText());
// };

