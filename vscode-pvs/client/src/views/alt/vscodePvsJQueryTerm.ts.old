
/**
 * @module vscodePvsXTerm
 * @author Paolo Masci
 * @date 2021.03.10
 * @copyright 
 * Copyright 2019 United States Government as represented by the Administrator 
 * of the National Aeronautics and Space Administration. All Rights Reserved.
 *
 * Disclaimers
 *
 * No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
 * WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
 * WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
 * INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
 * FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM TO
 * THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
 * CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
 * OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
 * OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
 * FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
 * REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
 * AND DISTRIBUTES IT "AS IS."
 *
 * Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
 * AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
 * SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT.  IF RECIPIENT'S USE OF
 * THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
 * EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
 * PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
 * SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
 * STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
 * PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW.  RECIPIENT'S SOLE
 * REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
 * TERMINATION OF THIS AGREEMENT.
 **/

import {
    Uri, WebviewPanel, ExtensionContext, Terminal, TerminalOptions, 
    ExtensionTerminalOptions, TerminalExitStatus, window, ViewColumn
} from 'vscode';
import * as path from 'path';
import * as Handlebars from "handlebars";
import Backbone = require('backbone');
import * as utils from '../common/languageUtils';
import { LanguageClient } from 'vscode-languageclient';
import { PvsFormula, PvsioEvaluatorCommand, PvsTheory, serverEvent, serverRequest } from '../common/serverInterface';
import { PvsResponse } from '../common/pvs-gui';
import * as vscodeUtils from '../utils/vscode-utils';
import * as fsUtils from '../common/fsUtils';
import * as language from '../common/languageKeywords';
import { getEvaluatorHints } from '../common/commandUtils';

export interface XTermMessage {
    command: string,
    data?: any
};

enum xtermCommands {
    writeln = "writeln",
    write = "write",
    search = "search",
    hints = "hints"
};

export enum XTermEvents {
    sendText = "sendText",
    didMoveCursor = "didMoveCursor",
    didFindMatchingBracket = "didFindMatchingBracket"
};

export declare type SessionType = "prover" | "evaluator";

const theme = {
    dark: {
        foreground: {
            green: "mediumseagreen",
            blue: "steelblue",
            yellow: "yellow"
        }
    }
};

const htmlTemplate: string = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{title}}</title>
    {{#if style}}
    <style type="text/css">{{style}}</style>
    {{/if}}
    {{#each css}}
    <link rel="stylesheet" href="{{this}}">
    {{/each}}
    {{#each js}}
    <script src="{{this}}"></script>
    {{/each}}
</head>
<style>
span {
    font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;
    font-size: 12px;
    font-weight:normal;
}
</style>
<body>
    <div id="terminal" class="terminal"></div>

    <script>
    const vscode = acquireVsCodeApi();
    const sessionType = "{{sessionType}}"; // "evaluator" | "prover"

    //--------------------
    // utility functions
    //--------------------
    function parMatch (cmd) {
        if (cmd) {
            const regex = new RegExp(/\"[^\"]*\"/g);
            const text = cmd.replace(regex, ""); // remove text in double quotes, they are strings, and may contain parentheses as characters
            const openRegex = new RegExp(/\\(/g);
            const closeRegex = new RegExp(/\\)/g);
            let par = 0;
            while (openRegex.exec(text)) {
                par++;
            }
            while (closeRegex.exec(text)) {
                par--;
            }
            return par === 0;
        }
        return true;
    }
    function colorText(str, color) {
        return "[[b;" + color + ";]" + str + "]";
    }
    function pvsCliSyntaxHighlighting(text) {
        if (text) {
            {{#each syntax}}
            const {{id}}_regexp = new RegExp({{regex}});
            // console.log("applying syntax highlighing to {{id}}s", text, {{id}}_regexp.test(text));
            text = text.replace({{id}}_regexp, (str) => {
                return colorText(str, "{{color}}");
            });
            {{/each}}
        }
        return text;
    }
    function findMatchingOpenBracketIndex (text) {
        let par = 0;
        let quotes = 0;
        for (let i = 0; i < text.length; i++) {
            const pos = text.length - 1 - i;
            switch (text[pos]) {
                case "(": {
                    if (quotes % 2 === 0) { par++; }
                    if (par === 0) {
                        return pos;
                    }
                    break;
                }
                case ")": {
                    if (quotes % 2 === 0) { par--; }
                    break;
                }
                case '"': {
                    quotes++;
                    break;
                }
                default: {
                    break;
                }
            }
        }
        return -1;
    }
    function highlight (text, index) {
        if (text && index >= 0 && index < text.length) {
            const pre = text.substr(0, index);
            const par = "[[b;${theme.dark.foreground.yellow};]" + text[index] + "]";
            const post = text.substr(index + 1);
            return pre + par + post;
        }
        return text;
    }

    //--------------------
    // autocompletion vars
    //--------------------
    var cmd;
    var empty = {
        options: [],
        args: []
    };
    var commands = [ "RANDOM" ];
    var ul;

    //--------------------
    // formatters + prompt
    //--------------------
    $.terminal.defaults.formatters.push((text) => {
        let content = text;
        // parenthesis matcher
        const par = new RegExp(/\\)$/g).test(text);
        if (par) {
            console.log("searching matching parenthesis...", text);
            let index = findMatchingOpenBracketIndex(text);
            console.log("match found at ", index);
            content = highlight(text, index);
        }
        // syntax highligher
        return pvsCliSyntaxHighlighting(content);
    });
    $.terminal.defaults.prompt = colorText("{{prompt}}", "${theme.dark.foreground.blue}");
    //--------------------
    // terminal
    //--------------------
    $("#terminal").terminal(function (cmd) {
        vscode.postMessage({
            command: "${XTermEvents.sendText}",
            data: cmd
        });
    }, {
        name: "{{name}}",
        greetings: false,
        keymap: {
            ENTER: function (e, original) {
                const cmd = this.get_command();
                const readyToSend = (sessionType === "evaluator" && cmd && cmd.endsWith(";"))
                    || (sessionType === "prover" && parMatch(cmd));
                if (readyToSend) {
                    original();
                } else {
                    this.insert("\\n");
                }
            }
        },
        onInit: function(term) {
            // set listener for receiving messages from vscode-pvs
            window.addEventListener('message', async (event) => {
                const message = event.data; // JSON data sent by vscode-pvs
                switch (message.command) {
                    {{#each xtermCommands}}
                    case "{{this}}": {
                        console.log("[echo] {{this}} data", message.data);
                        term.echo(message.data + "\\r\\n");
                        break;
                    }
                    {{/each}}
                    case "${xtermCommands.hints}": {
                        commands = message.data;
                        console.log("autocomplete data", commands);
                        break;
                    }
                    default: {
                        break;
                    }
                }
            });
            // autocompletion
            const wrapper = term.find('.cmd-cursor-line').wrap('<span/>').parent().addClass('cmd-wrapper');
            ul = $('<ul></ul>').appendTo(wrapper);
            console.log("wrapper", wrapper);
            ul.on('click', 'li', function() {
                term.insert($(this).text());
                ul.empty();
            });
        },
        autocompleteMenu: true,
        keydown: function(e) {
            var term = this;
            // setTimeout because terminal is adding characters in keypress
            // we use keydown because we need to prevent default action for
            // tab and still execute custom code
            setTimeout(function() {
                ul.empty();
                var command = term.get_command();
                var name = command.match(/^([^\s]*)/)[0];
                if (name) {
                    var word = term.before_cursor(true);
                    var regex = new RegExp('^' + $.terminal.escape_regex(word));
                    var list = commands;
                    if (list) {
                        const matched = [];
                        for (let i = 0; i < list.length; i++) {
                            if (regex.test(list[i])) {
                                matched.push(list[i]);
                            }
                        }
                        let insert = false;
                        if (e.which === 9) { // 9 is TAB
                            insert = term.complete(matched);
                            console.log("insert", insert);
                        }
                        if (matched.length && !insert) {
                            ul.hide();
                            for (var i=0; i<matched.length; ++i) {
                                var str = matched[i].replace(regex, '');
                                $('<li>' + str + '</li>').appendTo(ul);
                            }
                            ul.show();
                        }
                    }
                }
            }, 0);
            if (e.which === 9) { // 9 is TAB
                console.log("TAB", commands);
                return false;
            }
        }
    });
    </script>
</body>
</html>`;

export class VSCodePvsXTerm extends Backbone.Model implements Terminal {
    protected client: LanguageClient;
    protected context: ExtensionContext;

    // terminal prompt
    protected prompt: string = "";

    // terminal name
    name: string;

    // session type
    protected sessionType: SessionType;

    // theory associated with this terminal
    protected theory: PvsTheory;

    // webview panel
    protected panel: WebviewPanel;

    processId: Thenable<number>;
    creationOptions: Readonly<TerminalOptions | ExtensionTerminalOptions>;
    exitStatus: TerminalExitStatus;

    /**
     * Constructor
     */
    constructor (client: LanguageClient) {
        super();
        this.client = client;
    }

    /**
     * Start evaluator
     */
    async startEvaluator (resource: string | { path: string } | { contextValue: string }): Promise<boolean> {
        if (window.activeTextEditor && window.activeTextEditor.document) {
            // if the file is currently open in the editor, save file first
            await window.activeTextEditor.document.save();
            if (!resource) {
                resource = { path: window.activeTextEditor.document.fileName };
            }
        }
        if (resource) {
            const desc: PvsFormula = vscodeUtils.resource2desc(resource);
            if (desc) {
                if (!desc.theoryName) {
                    // const document: vscode.TextDocument = window.activeTextEditor.document;
                    const info: { content: string, line: number } = (resource && resource["path"]) ? { content: await fsUtils.readFile(resource["path"]), line: 0 }
                        : { content: window.activeTextEditor.document.getText(), line: window.activeTextEditor.selection.active.line };
                    const theoryName: string = utils.findTheoryName(info.content, info.line);
                    desc.theoryName = (desc.fileExtension === ".tccs") ? 
                        theoryName.substr(0, theoryName.length - 5) // the theory name in the .tccs file ends with _TCCS
                            : theoryName;
                }
                if (desc.theoryName) {
                    desc.fileExtension = ".pvs"; // only pvs files can be evaluated
                    const success: boolean = await this.startEvaluatorSession(desc);
                    return success;
                } else {
                    vscodeUtils.showErrorMessage(`Error while trying to invoke PVSio (could not identify theory name, please check that the file typechecks correctly)`);
                }
            } else {
                console.error("[vscode-events-dispatcher] Error: pvsio-evaluator invoked over an unknown resource", resource);
            }
        } else {
            console.error("[vscode-events-dispatcher] Error: pvsio-evaluator invoked with null resource", resource);
        }
        return false;
    }

    /**
     * Internal function, used for coloring text.
     * This function is needed because the default ansi syntax does not seem to work with jquery.terminal.
     */
    protected colorText(str: string, color: string): string {
        return "[[b;" + color + ";]" + str + "]";
    }


    /**
     * Internal function, sends a startEvaluator message to pvs-server
     */
    protected async startEvaluatorSession (theory: PvsTheory): Promise<boolean> {
        this.theory = theory;
        this.sessionType = "evaluator"
        this.setPrompt(utils.pvsioPrompt + " ");
        this.setName(theory.theoryName);
        this.reveal();
        // send start-pvsio request to pvs-server
        this.client.sendRequest(serverRequest.startEvaluator, theory);
        const success: boolean = await new Promise((resolve, reject) => {
            this.client.onRequest(serverEvent.startEvaluatorResponse, (desc: { response: PvsResponse, args: PvsTheory }) => {
                const header: string = `\r\nStarting new PVSio evaluator session for theory ${this.colorText(this.theory.theoryName, "steelblue")}`;
                this.log(header);
                const banner: string = this.colorText(utils.pvsioBanner, theme.dark.foreground.green);
                this.log(banner, { autocomplete: true, hints: getEvaluatorHints() });
                resolve(true);
            });
        });
        return success;
    }

    /**
     * Sends a command to pvs-server
     */
    sendText(text: string, addNewLine?: boolean): void {
        const command: PvsioEvaluatorCommand = {
            cmd: text,
            ...this.theory
        };
        this.client.sendRequest(serverRequest.evaluatorCommand, command);
        this.client.onRequest(serverEvent.evaluatorCommandResponse, (data: {
            req: PvsioEvaluatorCommand,
            res: string,
            state: string
        }) => {
            this.log(data?.res, { autocomplete: true });
        });
    }
    show(preserveFocus?: boolean): void {
        this.reveal();
    }
    dispose(): void {
        this.hide();
    }
    
    activate (context: ExtensionContext) {
        this.context = context;
        // context.subscriptions.push(vscode.commands.registerCommand("vscode-pvs.x-term", () => {
        //     this.reveal();
        // }));
    }
    /**
     * write a string in the webview
     */
    log (txt: string, opt?: { autocomplete?: boolean, hints?: string[] }): void {
        // the pseudo terminal needs \r\n, because \n moves to the next line but keeps the column
        const data: string = txt.replace(/\n/g, "\r\n");
        const message: XTermMessage = {
            command: xtermCommands.write,
            data
        };
        this.panel?.webview?.postMessage(message);
        if (opt?.autocomplete) {
            this.updateAutocomplete(data, opt?.hints);
        }
    }
    /**
     * Updates autocomplete based on the current content of the terminal
     */
    updateAutocomplete (line: string, hints?: string[]): void {
        hints = hints || getEvaluatorHints(line, "");
        const message: XTermMessage = {
            command: xtermCommands.hints,
            data: hints
        };
        this.panel?.webview?.postMessage(message);
    }
    /**
     * Reveal the terminal
     */
    reveal (): void {
        if (!this.panel) {
            this.renderView();
        }
        this.panel.reveal()
    }
    /**
     * Hide the terminal
     */
    hide (): void {
        this.panel.dispose();
    }
    /**
     * Renders the content of the webview
     */
    renderView (): void {
        this.createWebView();
    }
    /**
     * Sets the prompt
     */
    setPrompt (prompt: string): void {
        this.prompt = prompt;
    }
    /**
     * Sets the terminal name
     */
    setName (name: string): void {
        this.name = name;
    }
    /**
     * Show the prompt
     */
    showPrompt (): void {
        const message: XTermMessage = {
            command: xtermCommands.write,
            data: this.colorText(this.prompt, theme.dark.foreground.blue)
        };
        this.panel?.webview?.postMessage(message);
    }
    /**
     * Internal function, creates the webview
     */
    protected createWebView () {
        if (this.panel) {
            this.panel.title = "x-term-pvs";
        } else {
            this.panel = this.panel || window.createWebviewPanel(
                'x-term-pvs', // Identifies the type of the webview. Used internally
                'x-term-pvs', // Title of the panel displayed to the user
                ViewColumn.One, // Editor column to show the new webview panel in.
                {
                    enableScripts: true,
                    retainContextWhenHidden: true
                }
            );
            try {
                // clean up data structures when webview is disposed
                this.panel.onDidDispose(
                    async () => {
                        // delete panel
                        this.panel = null;
                    },
                    null,
                    this.context.subscriptions
                );
                // Handle messages from the webview
                this.panel.webview.onDidReceiveMessage(
                    async (message: XTermMessage) => {
                        console.log("[vscode-xterm] Received message", message);
                        if (message) {
                            switch (message.command) {
                                case XTermEvents.sendText: {
                                    this.sendText(message?.data);
                                    break;
                                }
                                case XTermEvents.didFindMatchingBracket: {
                                    console.log("matching bracket at position", message.data);
                                    break;
                                }
                                case XTermEvents.didMoveCursor: {
                                    console.log(message.data);
                                    break;
                                }
                                default: {
                                    break;
                                }
                            }
                        }
                    },
                    undefined,
                    this.context.subscriptions
                );
                // Create webview content
                this.createContent();
            } catch (err) {
                console.error(err);
            }
        }
    }
    /**
     * Internal function, creates the html content of the webview
     */
    protected createContent (): void {
        // set webview content
        const termJsOnDisk: Uri = Uri.file(path.join(this.context.extensionPath, 'client/node_modules/jquery.terminal/js/jquery.terminal.min.js'));
        const termCssOnDisk: Uri = Uri.file(path.join(this.context.extensionPath, 'client/node_modules/jquery.terminal/css/jquery.terminal.min.css'));
        // const autocompleteAddonnOnDisk: Uri = Uri.file(path.join(this.context.extensionPath, 'client/node_modules/jquery.terminal/js/autocomplete_menu.js'));
        const jqueryOnDisk: Uri = Uri.file(path.join(this.context.extensionPath, 'client/node_modules/jquery/dist/jquery.min.js'));

        const css: Uri[] = [
            this.panel.webview.asWebviewUri(termCssOnDisk)
        ];
        const js: Uri[] = [
            this.panel.webview.asWebviewUri(jqueryOnDisk),
            this.panel.webview.asWebviewUri(termJsOnDisk),
            // this.panel.webview.asWebviewUri(autocompleteAddonnOnDisk)
        ];
        try {
            const content: string = Handlebars.compile(htmlTemplate, { noEscape: true })({
                css, js,
                xtermCommands: [
                    xtermCommands.write
                ],
                prompt: this.prompt,
                name: this.name,
                sessionType: this.sessionType,
                syntax: [
                    {
                        id: "number",
                        regex: new RegExp(language.PVS_NUMBER_REGEXP_SOURCE, "g"),
                        color: theme.dark.foreground.yellow
                    },
                    {
                        id: "operators",
                        regex: new RegExp(language.PVS_LANGUAGE_OPERATORS_REGEXP_SOURCE, "g"),
                        color: theme.dark.foreground.blue
                    },
                    {
                        id: "keywords",
                        regex: new RegExp(language.PVS_RESERVED_WORDS_REGEXP_SOURCE, "gi"),
                        color: theme.dark.foreground.blue
                    },
                    {
                        id: "function",
                        regex: new RegExp(language.PVS_LIBRARY_FUNCTIONS_REGEXP_SOURCE, "g"),
                        color: theme.dark.foreground.green
                    },
                    {
                        id: "builtin_types",
                        regex: new RegExp(language.PVS_BUILTIN_TYPE_REGEXP_SOURCE, "g"),
                        color: theme.dark.foreground.green
                    },
                    {
                        id: "true_false",
                        regex: new RegExp(language.PVS_TRUE_FALSE_REGEXP_SOURCE, "gi"),
                        color: theme.dark.foreground.blue
                    }
                ]
            });
            this.panel.webview.html = content;
        } catch (err) {
            console.error(err);
        }
    }
    
}